// Generated by jextract

package org.apache.tomcat.util.openssl;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.ValueLayout.*;
public class conf_method_st {

    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(
        ADDRESS.withName("name"),
        ADDRESS.withName("create"),
        ADDRESS.withName("init"),
        ADDRESS.withName("destroy"),
        ADDRESS.withName("destroy_data"),
        ADDRESS.withName("load_bio"),
        ADDRESS.withName("dump"),
        ADDRESS.withName("is_number"),
        ADDRESS.withName("to_int"),
        ADDRESS.withName("load")
    ).withName("conf_method_st");
    public static MemoryLayout $LAYOUT() {
        return conf_method_st.$struct$LAYOUT;
    }
    static final VarHandle name$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("name"));
    public static VarHandle name$VH() {
        return conf_method_st.name$VH;
    }
    public static MemoryAddress name$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.name$VH.get(seg);
    }
    public static void name$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.name$VH.set(seg, x);
    }
    public static MemoryAddress name$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.name$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void name$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.name$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor create$FUNC = FunctionDescriptor.of(ADDRESS,
        ADDRESS
    );
    static final MethodHandle create$MH = RuntimeHelper.downcallHandle(
        conf_method_st.create$FUNC, false
    );
    public interface create {

        jdk.incubator.foreign.MemoryAddress apply(jdk.incubator.foreign.MemoryAddress x0);
        static CLinker.UpcallStub allocate(create fi) {
            return RuntimeHelper.upcallStub(create.class, fi, conf_method_st.create$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;");
        }
        static CLinker.UpcallStub allocate(create fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(create.class, fi, conf_method_st.create$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;", scope);
        }
        static create ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (jdk.incubator.foreign.MemoryAddress)conf_method_st.create$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create"));
    public static VarHandle create$VH() {
        return conf_method_st.create$VH;
    }
    public static MemoryAddress create$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.create$VH.get(seg);
    }
    public static void create$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.create$VH.set(seg, x);
    }
    public static MemoryAddress create$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.create$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.create$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create create (MemorySegment segment) {
        return create.ofAddress(create$get(segment));
    }
    static final FunctionDescriptor init$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS
    );
    static final MethodHandle init$MH = RuntimeHelper.downcallHandle(
        conf_method_st.init$FUNC, false
    );
    public interface init {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static CLinker.UpcallStub allocate(init fi) {
            return RuntimeHelper.upcallStub(init.class, fi, conf_method_st.init$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static CLinker.UpcallStub allocate(init fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(init.class, fi, conf_method_st.init$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static init ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)conf_method_st.init$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle init$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("init"));
    public static VarHandle init$VH() {
        return conf_method_st.init$VH;
    }
    public static MemoryAddress init$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.init$VH.get(seg);
    }
    public static void init$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.init$VH.set(seg, x);
    }
    public static MemoryAddress init$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.init$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void init$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.init$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static init init (MemorySegment segment) {
        return init.ofAddress(init$get(segment));
    }
    static final FunctionDescriptor destroy$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS
    );
    static final MethodHandle destroy$MH = RuntimeHelper.downcallHandle(
        conf_method_st.destroy$FUNC, false
    );
    public interface destroy {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static CLinker.UpcallStub allocate(destroy fi) {
            return RuntimeHelper.upcallStub(destroy.class, fi, conf_method_st.destroy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static CLinker.UpcallStub allocate(destroy fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(destroy.class, fi, conf_method_st.destroy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static destroy ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)conf_method_st.destroy$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle destroy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("destroy"));
    public static VarHandle destroy$VH() {
        return conf_method_st.destroy$VH;
    }
    public static MemoryAddress destroy$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.destroy$VH.get(seg);
    }
    public static void destroy$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.destroy$VH.set(seg, x);
    }
    public static MemoryAddress destroy$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.destroy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void destroy$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.destroy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static destroy destroy (MemorySegment segment) {
        return destroy.ofAddress(destroy$get(segment));
    }
    static final FunctionDescriptor destroy_data$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS
    );
    static final MethodHandle destroy_data$MH = RuntimeHelper.downcallHandle(
        conf_method_st.destroy_data$FUNC, false
    );
    public interface destroy_data {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static CLinker.UpcallStub allocate(destroy_data fi) {
            return RuntimeHelper.upcallStub(destroy_data.class, fi, conf_method_st.destroy_data$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static CLinker.UpcallStub allocate(destroy_data fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(destroy_data.class, fi, conf_method_st.destroy_data$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static destroy_data ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)conf_method_st.destroy_data$MH.invokeExact((Addressable)addr, x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle destroy_data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("destroy_data"));
    public static VarHandle destroy_data$VH() {
        return conf_method_st.destroy_data$VH;
    }
    public static MemoryAddress destroy_data$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.destroy_data$VH.get(seg);
    }
    public static void destroy_data$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.destroy_data$VH.set(seg, x);
    }
    public static MemoryAddress destroy_data$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.destroy_data$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void destroy_data$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.destroy_data$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static destroy_data destroy_data (MemorySegment segment) {
        return destroy_data.ofAddress(destroy_data$get(segment));
    }
    static final FunctionDescriptor load_bio$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS,
        ADDRESS,
        ADDRESS
    );
    static final MethodHandle load_bio$MH = RuntimeHelper.downcallHandle(
        conf_method_st.load_bio$FUNC, false
    );
    public interface load_bio {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static CLinker.UpcallStub allocate(load_bio fi) {
            return RuntimeHelper.upcallStub(load_bio.class, fi, conf_method_st.load_bio$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static CLinker.UpcallStub allocate(load_bio fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(load_bio.class, fi, conf_method_st.load_bio$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static load_bio ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)conf_method_st.load_bio$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle load_bio$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("load_bio"));
    public static VarHandle load_bio$VH() {
        return conf_method_st.load_bio$VH;
    }
    public static MemoryAddress load_bio$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.load_bio$VH.get(seg);
    }
    public static void load_bio$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.load_bio$VH.set(seg, x);
    }
    public static MemoryAddress load_bio$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.load_bio$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void load_bio$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.load_bio$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static load_bio load_bio (MemorySegment segment) {
        return load_bio.ofAddress(load_bio$get(segment));
    }
    static final FunctionDescriptor dump$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS,
        ADDRESS
    );
    static final MethodHandle dump$MH = RuntimeHelper.downcallHandle(
        conf_method_st.dump$FUNC, false
    );
    public interface dump {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static CLinker.UpcallStub allocate(dump fi) {
            return RuntimeHelper.upcallStub(dump.class, fi, conf_method_st.dump$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static CLinker.UpcallStub allocate(dump fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(dump.class, fi, conf_method_st.dump$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static dump ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)conf_method_st.dump$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle dump$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dump"));
    public static VarHandle dump$VH() {
        return conf_method_st.dump$VH;
    }
    public static MemoryAddress dump$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.dump$VH.get(seg);
    }
    public static void dump$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.dump$VH.set(seg, x);
    }
    public static MemoryAddress dump$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.dump$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dump$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.dump$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static dump dump (MemorySegment segment) {
        return dump.ofAddress(dump$get(segment));
    }
    static final FunctionDescriptor is_number$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS,
        JAVA_BYTE
    );
    static final MethodHandle is_number$MH = RuntimeHelper.downcallHandle(
        conf_method_st.is_number$FUNC, false
    );
    public interface is_number {

        int apply(jdk.incubator.foreign.MemoryAddress x0, byte x1);
        static CLinker.UpcallStub allocate(is_number fi) {
            return RuntimeHelper.upcallStub(is_number.class, fi, conf_method_st.is_number$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;B)I");
        }
        static CLinker.UpcallStub allocate(is_number fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(is_number.class, fi, conf_method_st.is_number$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;B)I", scope);
        }
        static is_number ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, byte x1) -> {
                try {
                    return (int)conf_method_st.is_number$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle is_number$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("is_number"));
    public static VarHandle is_number$VH() {
        return conf_method_st.is_number$VH;
    }
    public static MemoryAddress is_number$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.is_number$VH.get(seg);
    }
    public static void is_number$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.is_number$VH.set(seg, x);
    }
    public static MemoryAddress is_number$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.is_number$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void is_number$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.is_number$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static is_number is_number (MemorySegment segment) {
        return is_number.ofAddress(is_number$get(segment));
    }
    static final FunctionDescriptor to_int$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS,
        JAVA_BYTE
    );
    static final MethodHandle to_int$MH = RuntimeHelper.downcallHandle(
        conf_method_st.to_int$FUNC, false
    );
    public interface to_int {

        int apply(jdk.incubator.foreign.MemoryAddress x0, byte x1);
        static CLinker.UpcallStub allocate(to_int fi) {
            return RuntimeHelper.upcallStub(to_int.class, fi, conf_method_st.to_int$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;B)I");
        }
        static CLinker.UpcallStub allocate(to_int fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(to_int.class, fi, conf_method_st.to_int$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;B)I", scope);
        }
        static to_int ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, byte x1) -> {
                try {
                    return (int)conf_method_st.to_int$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle to_int$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("to_int"));
    public static VarHandle to_int$VH() {
        return conf_method_st.to_int$VH;
    }
    public static MemoryAddress to_int$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.to_int$VH.get(seg);
    }
    public static void to_int$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.to_int$VH.set(seg, x);
    }
    public static MemoryAddress to_int$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.to_int$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void to_int$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.to_int$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static to_int to_int (MemorySegment segment) {
        return to_int.ofAddress(to_int$get(segment));
    }
    static final FunctionDescriptor load$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS,
        ADDRESS,
        ADDRESS
    );
    static final MethodHandle load$MH = RuntimeHelper.downcallHandle(
        conf_method_st.load$FUNC, false
    );
    public interface load {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static CLinker.UpcallStub allocate(load fi) {
            return RuntimeHelper.upcallStub(load.class, fi, conf_method_st.load$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }
        static CLinker.UpcallStub allocate(load fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(load.class, fi, conf_method_st.load$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static load ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)conf_method_st.load$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle load$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("load"));
    public static VarHandle load$VH() {
        return conf_method_st.load$VH;
    }
    public static MemoryAddress load$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.load$VH.get(seg);
    }
    public static void load$set( MemorySegment seg, MemoryAddress x) {
        conf_method_st.load$VH.set(seg, x);
    }
    public static MemoryAddress load$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)conf_method_st.load$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void load$set(MemorySegment seg, long index, MemoryAddress x) {
        conf_method_st.load$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static load load (MemorySegment segment) {
        return load.ofAddress(load$get(segment));
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


