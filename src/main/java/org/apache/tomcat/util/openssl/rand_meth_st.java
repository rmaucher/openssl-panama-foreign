// Generated by jextract

package org.apache.tomcat.util.openssl;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.ValueLayout.*;
public class rand_meth_st {

    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(
        ADDRESS.withName("seed"),
        ADDRESS.withName("bytes"),
        ADDRESS.withName("cleanup"),
        ADDRESS.withName("add"),
        ADDRESS.withName("pseudorand"),
        ADDRESS.withName("status")
    ).withName("rand_meth_st");
    public static MemoryLayout $LAYOUT() {
        return rand_meth_st.$struct$LAYOUT;
    }
    static final FunctionDescriptor seed$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS,
        JAVA_INT
    );
    static final MethodHandle seed$MH = RuntimeHelper.downcallHandle(
        rand_meth_st.seed$FUNC, false
    );
    public interface seed {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1);
        static CLinker.UpcallStub allocate(seed fi) {
            return RuntimeHelper.upcallStub(seed.class, fi, rand_meth_st.seed$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I");
        }
        static CLinker.UpcallStub allocate(seed fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(seed.class, fi, rand_meth_st.seed$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static seed ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1) -> {
                try {
                    return (int)rand_meth_st.seed$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle seed$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("seed"));
    public static VarHandle seed$VH() {
        return rand_meth_st.seed$VH;
    }
    public static MemoryAddress seed$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.seed$VH.get(seg);
    }
    public static void seed$set( MemorySegment seg, MemoryAddress x) {
        rand_meth_st.seed$VH.set(seg, x);
    }
    public static MemoryAddress seed$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.seed$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void seed$set(MemorySegment seg, long index, MemoryAddress x) {
        rand_meth_st.seed$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static seed seed (MemorySegment segment) {
        return seed.ofAddress(seed$get(segment));
    }
    static final FunctionDescriptor bytes$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS,
        JAVA_INT
    );
    static final MethodHandle bytes$MH = RuntimeHelper.downcallHandle(
        rand_meth_st.bytes$FUNC, false
    );
    public interface bytes {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1);
        static CLinker.UpcallStub allocate(bytes fi) {
            return RuntimeHelper.upcallStub(bytes.class, fi, rand_meth_st.bytes$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I");
        }
        static CLinker.UpcallStub allocate(bytes fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(bytes.class, fi, rand_meth_st.bytes$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static bytes ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1) -> {
                try {
                    return (int)rand_meth_st.bytes$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle bytes$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bytes"));
    public static VarHandle bytes$VH() {
        return rand_meth_st.bytes$VH;
    }
    public static MemoryAddress bytes$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.bytes$VH.get(seg);
    }
    public static void bytes$set( MemorySegment seg, MemoryAddress x) {
        rand_meth_st.bytes$VH.set(seg, x);
    }
    public static MemoryAddress bytes$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.bytes$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void bytes$set(MemorySegment seg, long index, MemoryAddress x) {
        rand_meth_st.bytes$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static bytes bytes (MemorySegment segment) {
        return bytes.ofAddress(bytes$get(segment));
    }
    static final FunctionDescriptor cleanup$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle cleanup$MH = RuntimeHelper.downcallHandle(
        rand_meth_st.cleanup$FUNC, false
    );
    public interface cleanup {

        void apply();
        static CLinker.UpcallStub allocate(cleanup fi) {
            return RuntimeHelper.upcallStub(cleanup.class, fi, rand_meth_st.cleanup$FUNC, "()V");
        }
        static CLinker.UpcallStub allocate(cleanup fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(cleanup.class, fi, rand_meth_st.cleanup$FUNC, "()V", scope);
        }
        static cleanup ofAddress(MemoryAddress addr) {
            return () -> {
                try {
                    rand_meth_st.cleanup$MH.invokeExact((Addressable)addr);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle cleanup$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("cleanup"));
    public static VarHandle cleanup$VH() {
        return rand_meth_st.cleanup$VH;
    }
    public static MemoryAddress cleanup$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.cleanup$VH.get(seg);
    }
    public static void cleanup$set( MemorySegment seg, MemoryAddress x) {
        rand_meth_st.cleanup$VH.set(seg, x);
    }
    public static MemoryAddress cleanup$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.cleanup$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void cleanup$set(MemorySegment seg, long index, MemoryAddress x) {
        rand_meth_st.cleanup$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static cleanup cleanup (MemorySegment segment) {
        return cleanup.ofAddress(cleanup$get(segment));
    }
    static final FunctionDescriptor add$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS,
        JAVA_INT,
        JAVA_DOUBLE
    );
    static final MethodHandle add$MH = RuntimeHelper.downcallHandle(
        rand_meth_st.add$FUNC, false
    );
    public interface add {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, double x2);
        static CLinker.UpcallStub allocate(add fi) {
            return RuntimeHelper.upcallStub(add.class, fi, rand_meth_st.add$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ID)I");
        }
        static CLinker.UpcallStub allocate(add fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(add.class, fi, rand_meth_st.add$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ID)I", scope);
        }
        static add ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1, double x2) -> {
                try {
                    return (int)rand_meth_st.add$MH.invokeExact((Addressable)addr, x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle add$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("add"));
    public static VarHandle add$VH() {
        return rand_meth_st.add$VH;
    }
    public static MemoryAddress add$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.add$VH.get(seg);
    }
    public static void add$set( MemorySegment seg, MemoryAddress x) {
        rand_meth_st.add$VH.set(seg, x);
    }
    public static MemoryAddress add$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.add$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void add$set(MemorySegment seg, long index, MemoryAddress x) {
        rand_meth_st.add$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static add add (MemorySegment segment) {
        return add.ofAddress(add$get(segment));
    }
    static final FunctionDescriptor pseudorand$FUNC = FunctionDescriptor.of(JAVA_INT,
        ADDRESS,
        JAVA_INT
    );
    static final MethodHandle pseudorand$MH = RuntimeHelper.downcallHandle(
        rand_meth_st.pseudorand$FUNC, false
    );
    public interface pseudorand {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1);
        static CLinker.UpcallStub allocate(pseudorand fi) {
            return RuntimeHelper.upcallStub(pseudorand.class, fi, rand_meth_st.pseudorand$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I");
        }
        static CLinker.UpcallStub allocate(pseudorand fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(pseudorand.class, fi, rand_meth_st.pseudorand$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static pseudorand ofAddress(MemoryAddress addr) {
            return (jdk.incubator.foreign.MemoryAddress x0, int x1) -> {
                try {
                    return (int)rand_meth_st.pseudorand$MH.invokeExact((Addressable)addr, x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle pseudorand$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("pseudorand"));
    public static VarHandle pseudorand$VH() {
        return rand_meth_st.pseudorand$VH;
    }
    public static MemoryAddress pseudorand$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.pseudorand$VH.get(seg);
    }
    public static void pseudorand$set( MemorySegment seg, MemoryAddress x) {
        rand_meth_st.pseudorand$VH.set(seg, x);
    }
    public static MemoryAddress pseudorand$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.pseudorand$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void pseudorand$set(MemorySegment seg, long index, MemoryAddress x) {
        rand_meth_st.pseudorand$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static pseudorand pseudorand (MemorySegment segment) {
        return pseudorand.ofAddress(pseudorand$get(segment));
    }
    static final FunctionDescriptor status$FUNC = FunctionDescriptor.of(JAVA_INT);
    static final MethodHandle status$MH = RuntimeHelper.downcallHandle(
        rand_meth_st.status$FUNC, false
    );
    public interface status {

        int apply();
        static CLinker.UpcallStub allocate(status fi) {
            return RuntimeHelper.upcallStub(status.class, fi, rand_meth_st.status$FUNC, "()I");
        }
        static CLinker.UpcallStub allocate(status fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(status.class, fi, rand_meth_st.status$FUNC, "()I", scope);
        }
        static status ofAddress(MemoryAddress addr) {
            return () -> {
                try {
                    return (int)rand_meth_st.status$MH.invokeExact((Addressable)addr);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle status$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("status"));
    public static VarHandle status$VH() {
        return rand_meth_st.status$VH;
    }
    public static MemoryAddress status$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.status$VH.get(seg);
    }
    public static void status$set( MemorySegment seg, MemoryAddress x) {
        rand_meth_st.status$VH.set(seg, x);
    }
    public static MemoryAddress status$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)rand_meth_st.status$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void status$set(MemorySegment seg, long index, MemoryAddress x) {
        rand_meth_st.status$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static status status (MemorySegment segment) {
        return status.ofAddress(status$get(segment));
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


